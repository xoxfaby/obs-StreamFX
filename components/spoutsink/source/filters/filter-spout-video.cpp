// AUTOGENERATED COPYRIGHT HEADER START
// Copyright (C) 2023 Michael Fabian 'Xaymar' Dirks <info@xaymar.com>
// AUTOGENERATED COPYRIGHT HEADER END

#include "filter-spout-video.hpp"
#include "strings.hpp"
#include "plugin.hpp"
#include "util/util-logging.hpp"

#include "warning-disable.hpp"
#include <algorithm>
#include <stdexcept>
#include "warning-enable.hpp"

// OBS
#include "warning-disable.hpp"
#include "warning-enable.hpp"

#ifdef _DEBUG
#define ST_PREFIX "<%s> "
#define D_LOG_ERROR(x, ...) P_LOG_ERROR(ST_PREFIX##x, __FUNCTION_SIG__, __VA_ARGS__)
#define D_LOG_WARNING(x, ...) P_LOG_WARN(ST_PREFIX##x, __FUNCTION_SIG__, __VA_ARGS__)
#define D_LOG_INFO(x, ...) P_LOG_INFO(ST_PREFIX##x, __FUNCTION_SIG__, __VA_ARGS__)
#define D_LOG_DEBUG(x, ...) P_LOG_DEBUG(ST_PREFIX##x, __FUNCTION_SIG__, __VA_ARGS__)
#else
#define ST_PREFIX "<filter::spout::asyncvideo> "
#define D_LOG_ERROR(...) P_LOG_ERROR(ST_PREFIX __VA_ARGS__)
#define D_LOG_WARNING(...) P_LOG_WARN(ST_PREFIX __VA_ARGS__)
#define D_LOG_INFO(...) P_LOG_INFO(ST_PREFIX __VA_ARGS__)
#define D_LOG_DEBUG(...) P_LOG_DEBUG(ST_PREFIX __VA_ARGS__)
#endif

#define ST_I18N "Filter.Spout.Video"
#define ST_I18N_NAME ST_I18N ".Name"
#define ST_KEY_NAME "Name"

using namespace streamfx::filter::spout;

video_instance::video_instance(obs_data_t* data, obs_source_t* context) : obs::source_instance(data, context) {}

video_instance::~video_instance() {}

void video_instance::load(obs_data_t* settings) {}

void video_instance::migrate(obs_data_t* settings, uint64_t version) {}

void video_instance::update(obs_data_t* settings) {}

struct obs_audio_data* video_instance::filter_audio(struct obs_audio_data* audio)
{
	return audio;
}

void video_instance::video_tick(float)
{
	// What information do we need to provide to downstream consumers?
	// - Width, Height (Resolution)
	// - Color Space
	// - Color Format

	auto parent = _self.get_filter_parent();
	auto target = _self.get_filter_target();

	// Retrieve resolution.
	_resolution = {target.width(), target.height()};

	// Retrieve both color format and space.
	_color_space = GS_CS_SRGB;
	_color_space = target.color_space(1, &_color_space);
	switch (_color_space) {
	case GS_CS_SRGB:
		_color_format = GS_RGBA;
		break;
	default:
		_color_format = GS_RGBA16F;
		break;
	}



}

void video_instance::video_render(gs_effect_t* effect)
{
	auto parent = _self.get_filter_parent();
	auto target = _self.get_filter_target();

	//_self.process_filter_begin(_color_format, OBS_ALLOW_DIRECT_RENDERING);

	obs_source_skip_video_filter(_self);
}

video_factory::video_factory()
{
	_info.id           = S_PREFIX "filter-spout-video";
	_info.type         = OBS_SOURCE_TYPE_FILTER;
	_info.output_flags = OBS_SOURCE_VIDEO;

	support_size(false);
	finish_setup();
}

video_factory::~video_factory() {}

const char* video_factory::get_name()
{
	return D_TRANSLATE(ST_I18N);
}

void video_factory::get_defaults2(obs_data_t* settings)
{
	obs_data_set_default_string(settings, ST_KEY_NAME, "${SOURCE}/${FILTER}");
}

obs_properties_t* video_factory::get_properties2(video_instance* data)
{
	obs_properties_t* pr = obs_properties_create();

	{
		auto p = obs_properties_add_text(pr, ST_KEY_NAME, D_TRANSLATE(ST_I18N_NAME), obs_text_type::OBS_TEXT_DEFAULT);
	}

	return pr;
}

std::shared_ptr<video_factory> video_factory::instance()
{
	static std::weak_ptr<video_factory> winst;
	static std::mutex                   mtx;

	std::unique_lock<decltype(mtx)> lock(mtx);
	auto                            instance = winst.lock();
	if (!instance) {
		instance = std::shared_ptr<video_factory>(new video_factory());
		winst    = instance;
	}
	return instance;
}

static std::shared_ptr<video_factory> loader_instance;

static auto loader = streamfx::component(
	"spoutsink::video",
	[]() { // Initializer
		loader_instance = video_factory::instance();
	},
	[]() { // Finalizer
		loader_instance.reset();
	},
	{});
